#include <algorithm>
#include <iostream>
#include <initializer_list>
#include <iterator>
using namespace std;

template <typename T>
struct Node{
        T my_data;
        Node* next;
        Node() = default;
        constexpr explicit Node(T d) : my_data(d) {}
        operator T(){
            return my_data;
        }
        operator T() const{
            return my_data;
        }
        T* operator&(){
            return &my_data;
        }
        Node operator++(){
            return next;
        }
    };

template <typename T>
class forward_list{
    private:
        Node<T>* my_head;
        Node<T>* my_tail;
        size_t my_size;

        

    public:
        using value_type            = T;
        using size_type             = size_t;
        //todo difference type
        using reference             = T&; 
        using const_reference       = const T&;
        using pointer               = T*;
        using const_pointer         = const T;
        
        typedef iterator_base<Node<T>>            iterator;
        typedef const iterator_base<Node<T>>      const_iterator;

        typedef reverse_iterator_base<Node<T>>         reverse_iterator;
        typedef const reverse_iterator_base<Node<T>>   const_reverse_iterator;

    forward_list(){
        my_head = nullptr;
        my_tail = nullptr;
        my_size = 0;
    }

    // ELEMENT ACCESS
    reference front(){
        return my_head->my_data;
    }

    const_reference front() const{
        return my_head->my_data;
    }

    // ITERATORS
    iterator begin() noexcept{
        return iterator(my_head);
    }
    const_iterator begin() const noexcept{
        return const_iteratorq(my_head);
    }
    const_iterator cbegin() const noexcept{
        return const_iteratorq(my_head);
    }

    iterator end() noexcept{
        return iterator(my_tail->next);
    }
    const_iterator end() const noexcept{
        return const_iterator(my_tail->next);
    }
    const_iterator cend() const noexcept{
        return const_iterator(my_tail->next);
    }

    // CAPACITY
    bool empty() const noexcept{
        return my_size == 0;
    }

    size_type max_size() const noexcept;

    // MODIFIERS
    void clear() noexcept{
        my_size = 0;
        while(my_head != my_tail){
            Node<T>* temp = my_head;
            my_head = my_head->next;
            delete temp;
        }
        my_head = nullptr;
        my_tail = nullptr;
    }

    iterator insert_after( const_iterator pos, const T& value ){
        T val = value;
        Node<T> p = *pos;
        Node<T>* new_node = new Node<T>(val);
        new_node->next = p.next;
        p.next = new_node;
        my_size++;
        return iterator(new_node);
    }
    iterator insert_after( const_iterator pos, T&& value ){
        T val = value;
        Node<T> p = *pos;
        Node<T>* new_node = new Node<T>(val);
        new_node->next = p.next;
        p.next = new_node;
        my_size++;
        return iterator(new_node);
    }
    iterator insert_after( const_iterator pos, size_type count, const T& value ){
        if(count == 0){
            return iterator(pos);
        }
        T val = value;
        Node<T> p = *pos;
        Node<T>* curr = &p;
        for(int i=0; i<count; i++){
            Node<T>* new_node = new Node<T>(val);
            new_node->next = curr->next;
            curr->next = new_node;
            curr = new_node;
            my_size++;
        }
        return iterator(curr);
    }
    template< class InputIt >
    iterator insert_after( const_iterator pos, InputIt first, InputIt last ){
        if(first==last){
            return iterator(pos);
        }
        Node<T> p = *pos;
        Node<T>* curr = &p;
        InputIt c = first;
        while(c != last){
            Node<T>* new_node = new Node<T>(*c);
            new_node->next = curr->next;
            curr->next = new_node;
            curr = new_node;
            my_size++;
            c++;
        }
        Node<T>* new_node = new Node<T>(*c);
        new_node->next = curr->next;
        curr->next = new_node;
        curr = new_node;
        my_size++;
        return iterator(curr);
    }
    iterator insert_after( const_iterator pos, std::initializer_list<T> ilist ){
        size_t count = ilist.size();
        if(count == 0){
            return iterator(pos);
        }
        Node<T> p = *pos;
        Node<T>* curr = &p;
        for(int i=0; i<count;i++){
            Node<T>* new_node = new Node<T>(ilist[i]);
            new_node->next = curr->next;
            curr->next = new_node;
            curr = new_node;
            my_size++;
        }
        return iterator(curr);
    }

    template< class... Args >
    iterator emplace_after( const_iterator pos, Args&&... args );
 
    iterator erase_after( const_iterator pos ){
        Node<T> p = *pos;
        Node<T>* temp = p.next;
        p.next = temp->next;
        delete temp;
        return iterator(p.next);
    }
    iterator erase_after( const_iterator first, const_iterator last ){
        if(first == last){
            return iterator(last);
        }
        Node<T> f = *first;
        Node<T>* curr = f.next;
        Node<T> l = *last;
        Node<T>* ret = l.next;
        while(curr != ret){
            Node<T>* temp = curr;
            curr = curr->next;
            delete temp;
        }
        f.next = ret;
        return iterator(ret);
        
    }


    void push_front(value_type data){
        //new node
        Node<T>* new_node = new Node<T>(data);
        //empty list
        if (my_size == 0){
            my_head = new_node;
            my_tail = new_node;
            my_size = 1;
        }
        //not empty list
        {
            //list size 1
            if (my_size == 1){
                my_tail = new_node;
                my_head->next = new_node;
                my_size++;
            }
            //list size > 1
            else{
                my_tail->next = new_node;
                my_tail = new_node;
                my_size++;
            }
        }
    }
};