#include <algorithm>
#include <iostream>
#include <initializer_list>
#include <iterator>
using namespace std;

template <typename T, size_t S>
class array{
    private:
        size_t my_size;
        T* p;

    public:
        using value_type            = T;
        using size_type             = size_t;
        //todo difference type
        using reference             = T&; 
        using const_reference       = const T&;
        using pointer               = T*;
        using const_pointer         = const T;
        
        typedef iterator_base<T>            iterator;
        typedef const iterator_base<T>      const_iterator;

        typedef reverse_iterator_base<T>         reverse_iterator;
        typedef const reverse_iterator_base<T>   const_reverse_iterator;
        
    array(){
        my_size = S;
        p = new T[S];
    }
    array(initializer_list<T> i);

    void operator=(initializer_list<T> i);

    
    //ELEMENT ACCESS

    T& at(int index);

    T& operator[](int index){
        return p[index];
    }


    T& front(){
        return p[0];
    }

    T& back(){
        return p[my_size-1];
    }

    T* data();

    //iterators
    //begin -- Done
    iterator begin(){
        return iterator(&p[0]);
    }

    const_iterator begin() const{
        return const_iterator(&p[0]);
    }

    const_iterator cbegin() const{
        return const_iterator(&p[0]);
    }

    iterator end();

    //CAPACITY
    bool empty();

    size_t size(){
        return my_size;
    }

    int max_size();

    //OPERATIONS
    void fill(const T& val);

    void swap(array<T,S> new_array);

    
};