#include <utility>
#include <vector>
#ifndef MAP_H
#define MAP_H

namespace std{
    template<class Key, class T>
    class map {
        private:
            int capacity;
            int current;
            vector<pair<Key, T>> values;
        public:
            using key_type      = Key;
            using mapped_type   = T;
            using size_type     = int;

            struct const_iterator
            {
                using value_type = std::pair<Key, T>;
                using pointer = std::pair<Key, T>; 
                using reference = std::pair<Key, T>&;

                const_iterator(pointer ptr) : m_ptr(ptr) {}

                pointer* operator ->() { return &m_ptr; }

                private:
                pointer m_ptr;
            };

            // capacity
            bool empty() { return current == 0; }
            size_type size() {}
            size_type max_size() {}

            // element access
            mapped_type& operator[] (const key_type& x) {}
            mapped_type& operator[] (key_type& x) {}
            mapped_type&            at(const key_type& x) {}
            const mapped_type&      at(const key_type& x) const {}

            //modifiers
            void insert(pair<Key, T> p);
            const_iterator begin();
    }; // end map class

    template<class Key, class T>
    void map<Key, T>::insert(pair<Key, T> p) {

    }

    template<class Key, class T>
    typename map<Key, T>::const_iterator map<Key, T>::begin(){
        return map<Key, T>::const_iterator(values[0]);
    }

} // end namespace std

#endif