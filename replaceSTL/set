#ifndef SET_H_
#define SET_H_

namespace std{
    template <typename T>
    class set {
    private:

        T val;
    public:

        // types
        using key_type          = Key;
        using value_type        = Key;
        using reference         = value_type&;
        using const_reference   = const value_type&;
        using size_type         = size_t;

        // construct/copy/destroy

        // iterators
        iterator               begin();
        const_iterator         begin() const;
        iterator               end();
        const_iterator         end() const;
    
        reverse_iterator       rbegin();
        const_reverse_iterator rbegin() const;
        reverse_iterator       rend();
        const_reverse_iterator rend() const;
    
        const_iterator         cbegin() const;
        const_iterator         cend() const;
        const_reverse_iterator crbegin() const;
        const_reverse_iterator crend() const;

        // capacity
        bool empty() const;
        size_type size() const;
        size_type max_size() const;

        // modifiers
        template<class... Args> pair<iterator, bool> emplace(Args&&... args);
        template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
        pair<iterator,bool> insert(const value_type& x);
        pair<iterator,bool> insert(value_type&& x);
        iterator insert(const_iterator position, const value_type& x);
        iterator insert(const_iterator position, value_type&& x);
        template<class InputIt>
        void insert(InputIt first, InputIt last);
        void insert(initializer_list<value_type>);

        node_type extract(const_iterator position);
        node_type extract(const key_type& x);
        template<class K> node_type extract(K&& x);

        insert_return_type insert(node_type&& nh);
        iterator           insert(const_iterator hint, node_type&& nh);

        iterator  erase(iterator position);
        iterator  erase(const_iterator position);
        size_type erase(const key_type& x);
        template<class K> size_type erase(K&& x);
        iterator  erase(const_iterator first, const_iterator last);
        void      swap(set&)
        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
                is_nothrow_swappable_v<Compare>);
        void      clear() noexcept;

        template<class C2>
        void merge(set<Key, C2, Allocator>& source);
        template<class C2>
        void merge(set<Key, C2, Allocator>&& source);
        template<class C2>
        void merge(multiset<Key, C2, Allocator>& source);
        template<class C2>
        void merge(multiset<Key, C2, Allocator>&& source);

        // set operations
        iterator       find(const key_type& x);
        const_iterator find(const key_type& x) const;
        template<class K> iterator       find(const K& x);
        template<class K> const_iterator find(const K& x) const;
    
        size_type      count(const key_type& x) const;
        template<class K> size_type count(const K& x) const;
    
        bool           contains(const key_type& x) const;
        template<class K> bool contains(const K& x) const;
    
        iterator       lower_bound(const key_type& x);
        const_iterator lower_bound(const key_type& x) const;
        template<class K> iterator       lower_bound(const K& x);
        template<class K> const_iterator lower_bound(const K& x) const;
    
        iterator       upper_bound(const key_type& x);
        const_iterator upper_bound(const key_type& x) const;
        template<class K> iterator       upper_bound(const K& x);
        template<class K> const_iterator upper_bound(const K& x) const;
    
        pair<iterator, iterator>               equal_range(const key_type& x);
        pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
        template<class K>
        pair<iterator, iterator>             equal_range(const K& x);
        template<class K>
        pair<const_iterator, const_iterator> equal_range(const K& x) const;
    };
}

#endif